[.text-4xl]
[.text-white]
== 2 - Scripting on Index Data
image::blue-background.png[background, size=cover]

[.text-3xl]
== Scripting on Index Data
image::white-background.png[background, size=cover]

* In this lesson, you will learn to access and process index data in your scripts. You will

** Understand how Painless contexts expose index data to a script

** Learn to create a runtime field

** Learn to modify the _source of a document during an update and populate a field with values based on other field values or user-defined parameters

** Learn to create a custom filter for use in a query

** Learn how to control the order in which documents are returned during a query using a script to create new sort keys

[.text-4xl]
[.text-white]
== Painless Contexts
image::green-background.png[background, size=cover]

[.text-3xl]
== Painless Contexts
image::white-background.png[background, size=cover]

* A Painless script is evaluated within the *context* of an Elasticsearch operation, such as update or search

** The context exposes data as local variables for use in the script

** The context may give access to the original document data stored in `_source`, indexed document data through the `doc` Map, or to user-defined script parameters through the `params` Map

* It is important to note that *a Painless script can only access the data exposed by a particular context* and has no direct access to internal data structures

[.text-3xl]
== Painless Contexts (continued)
image::white-background.png[background, size=cover]

* For example, during a query, the Painless *Field* context will expose the following data to a script:

** Document data stored in Elasticsearch data structures through the `doc` local variable (e.g., `doc['credit_score']`)

** The `_source` of the document through the `params['_source']` local variable (e.g., `params['_source']['name']`)

** Any user-defined parameters passed as part of the query through the `params` local variable (e.g., `params['good_interest_rate']`)

[.text-2xl]
== Using Scripts and Contexts
image::white-background.png[background, size=cover]

* Once we determine under which operation a script will execute:

** We need to refer to the documentation on the appropriate Painless context to understand what data is exposed to the script

* *We also want to isolate as much of our logic from the local variables of the context* — so we can reuse in other contexts

** To do this, we encapsulate our logic in Painless functions

** We therefore prefer not to write context-dependent code like

*** `p = 2 * Math.PI * doc['radius'].value`

* But instead we prefer to write code like

** `p = perimeter(doc['radius'].value)` 

*** where `perimeter` is a function defined in the script

[.text-4xl]
[.text-white]
== Runtime Fields
image::green-background.png[background, size=cover]

[.text-2xl]
== Revisiting the Loan Interest Rate App
image::white-background.png[background, size=cover]

[.text-left]

* We can now see that the query we wrote to generate a loan quote uses the Field context to access a borrower’s data and determine the interest rate the bank will offer

```
include::../code/010_loan_quote_intro_example.painless[]
```

[.text-2xl]
== Isolating Logic in a Function
image::white-background.png[background, size=cover]

[.text-left]
* To use our loan quote solution across Painless contexts, we can encapsulate the logic in a getLoanQuote function

```
include::../code/get_loan_function.painless[]
```

[.text-2xl]
== Testing the Logic in Isolation
image::white-background.png[background, size=cover]

[.text-left]
* By refactoring the code in a script into one or more functions, we can test at a granular level

* Running the getLoanQuote function inside an _execute statement allows us to test it with different values

```
include::../code/get_loan_quote_function.painless[]
```

[.text-2xl]
=== Loan Quote Function Test Results
image::white-background.png[background, size=cover]

```
include::../code/get_loan_quote_function_results.painless[]
```

[.text-left]
* Painless does not yet have a testing framework, so this is the best that we can do for now

[.text-3xl]
== Isolating Logic (continued)
image::white-background.png[background, size=cover]

* Summarizing the benefits of using functions in scripts:

** The logic inside the function does not use the context’s local variables, but uses instead its own parameters

** Also note that we took the opportunity to improve the code a bit

** We also tested the code in isolation

** All this allows us to use an incremental, building block approach to Painless script development

** We can now use `getLoanQuote` within any other Painless context

*** Let’s go ahead and refactor our current solution with our newly developed and tested `getLoanQuote` function 

[.text-3xl]
== Interest Rate Query Refactored
image::white-background.png[background, size=cover]

[.text-left]
* To refactor the query, we need to include the `getLoanQuote` function in the script and pass context data when we call it

```
include::../code/015_loan_quote_intro_example_refactored.painless[]
```

[.text-4xl]
[.text-white]
== Updating a Document
image::green-background.png[background, size=cover]

[.text-2xl]
== Using Painless to Update a Document
image::white-background.png[background, size=cover]

* We can use a Painless script to update a document in an index

** The Painless contexts for a single document update, an update-by-query and a reindex are practically identical

** This kind of context gives a Painless script access to

*** The user-defined `params` of the script

*** The document’s `_source` and meta-data, including `_id`, `_index`, and `_version`, through the `ctx` local variable

**** For example, `ctx[‘_source’][‘name’]` would be the value of the name field in a `borrowers` document

**** `ctx[_id]` would be the document id

**** `ctx[_index]` would be equal to"borrowers” 

[.text-2xl]
== Updating the Credit Rating
image::white-background.png[background, size=cover]

[.text-left]
* The following script adjusts the credit rating of a single borrower when used within an update context

```
include::../code/030_update_credit_rating_script.painless[]
```

[.text-2xl]
== Updating the Credit Rating (continued)
image::white-background.png[background, size=cover]

[.text-left]
* We can adjust a single borrower’s credit rating by invoking the script during an `_update` and passing the adjustment amount

```
include::../code/032_update_credit_rating_update.painless[]
```

[.text-2xl]
== Updating the Credit Rating (continued)
image::white-background.png[background, size=cover]

[.text-left]
* We can also update all the borrowers if we invoke the same script within an `_update_by_query`

```
include::../code/034_update_credit_rating_update_by_query.painless[]
```

[.text-2xl]
== Updating the Credit Rating (continued)
image::white-background.png[background, size=cover]

[.text-left]
* Or we can use the script to create `new_borrowers` after updating every `borrower`’s credit rating using `_reindex`

```
include::../code/036_update_credit_rating_reindex.painless[]
```

[.text-4xl]
[.text-white]
== Custom Filters
image::green-background.png[background, size=cover]

[.text-2xl]
== Scripted Filters
image::white-background.png[background, size=cover]

* The bank wants to find borrowers with a credit rating greater than the bank’s average rating multiplied by a given factor

* We can use a Painless script as a type of `filter`:

** The script needs to return either `true` or `false` to indicate whether it should be considered a hit or not

* We will be using the Painless *Filter* context which exposes document data through the doc local variable, plus any user-defined parameters


[.text-2xl]
== Scripted Filters (continued)
image::white-background.png[background, size=cover]

[.text-left]
* The requested query can then be written as follows using a scripted filter

```
include::../code/find_high_credit_rating_borrowers.painless[]
```

[.text-4xl]
[.text-white]
== Custom Sort
image::green-background.png[background, size=cover]

[.text-2xl]
== Custom Sort
image::white-background.png[background, size=cover]

[.text-left]
* The bank added a field to the borrowers index containing their current loan amounts

* Copy-paste the following `_update` statements to update your data

```
include::../code/040_add_current_loan_amount.painless[]
```

[.text-2xl]
== Custom Sort (continued)
image::white-background.png[background, size=cover]

* The bank would like a query ranking borrowers using the formula

** `credit_rating / 1000.0 * current_loan_total / 1000 * adjustment`

* We can sort the results of a query using this formula by embedding a script in the sort clause of a `_search`

** The script must return either a number or a string to be used as the value on which to sort a document

* We will be using the Painless *Sort* context which exposes document data through the `doc` local variable, plus any user-defined parameters

[.text-2xl]
== Custom Sort (continued)
image::white-background.png[background, size=cover]

[.text-left]
* A query that orders borrowers as requested by the bank can be written using a scripted sort clause as follows

```
include::../code/045_custom_sort.painless[]
```

[.text-2xl]
== Custom Sort Results
image::white-background.png[background, size=cover]

[.text-left]
* The value of the formula calculated by our script is returned in the results — so we get a borrower’s ranking, as well

** Note how borrower Joe was ranked higher than Mary because of their current loans!

```
include::../code/047_custom_sort_results.painless[]
```

[.text-4xl]
[.text-white]
== Summary: Scripting on Index Data
image::green-background.png[background, size=cover]

[.text-3xl]
== Summary
image::white-background.png[background, size=cover]

* In this lesson, you learned to access and process index data in your scripts

* Painless contexts provide access to index data through local variables in a script

* Runtime fields can be used to create new fields at query time and populate them with data from other fields, as well as script parameters

* Painless scripts can be used to modify a document during `_update`, `_update_by_query` and `_reindex`

* Scripts can be used to create custom filters for queries

* Scripts can be used to customized the ordering of documents in the results of a query

[.text-3xl]
== Quiz
image::white-background.png[background, size=cover]

. **True or False**: A script can only access index data through local variables provided by a Painless context

. In the Field context, what is the local variable that allows access to the original document that was indexed

. **True or False**: A script inside a filter must return either true or false as a result

. **True or False**: Painless scripts are cached by Elasticsearch

. **True or False**: It is not possible to combine sorting on script-generated values with field values in the same query

[.text-3xl]
=== Quiz Answers
image::white-background.png[background, size=cover]

. *True*

. `params['_source']`
. *True*

. *False*. Script-generated values can be used in the sort clause in combination with any other values (from other scripts or from fields)

[.text-4xl]
[.text-white]
== Lab 2: Scripting on Index Data
image::green-background.png[background, size=cover]