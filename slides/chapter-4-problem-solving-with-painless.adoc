[.text-4xl]
[.text-white]
== 4 - Problem Solving with Painless 
image::blue-background.png[background, size=cover]

[.text-3xl]
== Problem Solving with Painless 
image::white-background.png[background, size=cover]

* In this lesson, you will solve a complete problem using the scripting skills you have learned so far

* You will also follow a systematic solution approach that involves

** Becoming familiar with the data by analyzing the index mapping

** Breaking down the problem and build functions to solve the sub-problems

** Building a quick, initial solution and analyzing its merits

** Improving on the solution until it is ready for a production deployment

** The following slides contain code snippets to guide you through. If you want the complete code don't forget to look in Lab 0!

[.text-3xl]
== The Problem: Find the Duration of a Trip
image::white-background.png[background, size=cover]

[.text-left]
* Assume you have a trips index with two fields, departure_date and arrival_date and that there is a requirement to determine the trip’s duration (in hours and minutes) for display on a search page

* Assume further that the index was created by indexing documents in this manner:

```
include::../code/050_trip_duration_data.painless[]
```

[.text-left]
* That is, the mapping was generated dynamically by Elasticsearch

[.text-2xl]
== Analyzing the Mapping
image::white-background.png[background, size=cover]

[.text-left]
* Let’s start by inspecting the mapping

** We can see that Elasticsearch did not recognize the dates and indexed them instead as plain strings — it generated a text/keyword pair in the mapping for each of these fields

```
include::../code/052_trip_duration_mapping.painless[]
```

[.text-2xl]
== Parsing the Custom Dates
image::white-background.png[background, size=cover]

[.text-left]
* Let’s first build a function to read our custom-format date and convert it to a ZonedDateTime

```
include::../code/054_trip_duration_to_zoneddatetime.painless[]
```

[.text-2xl]
== Finding the Trip Duration
image::white-background.png[background, size=cover]

[.text-left]
* Next, we can build a function that will return the duration between to dates in hours and minutes

```
include::../code/056_trip_duration_trip_duration.painless[]
```

[.text-left]
** Note how we use a Map to hold the hours and minutes in a single object

[.text-2xl]
== An Initial Solution using a Runtime Field
image::white-background.png[background, size=cover]

[.text-left]
* With our two new functions as building blocks, we can quickly solve the problem using a runtime field `trip_duration`

```
include::../code/058_trip_duration_runtime_field.painless[]
```

[.text-2xl]
== Solution Results
image::white-background.png[background, size=cover]

[.text-left]
* The results from the query are ready to be used on the search page!

```
include::../code/060_trip_duration_results.painless[]
```

[.text-2xl]
== Initial Solution Analysis
image::white-background.png[background, size=cover]

* The Runtime Field solution was easy to write and allowed us to test our logic on index data

** We were able to test each function separately using _execute on dummy data, and now have confidence it will work on index data

* Our initial solution is just that, initial

** There is no reason to calculate `trip_duration` every time the query is executed since the trip dates will rarely, if ever, change

** The Runtime Field does work like any other field

*** We can use it to create visualizations, range queries, etc.

*** But it is not a computation we want to run over and over again when the query is run

* Once we are satisfied that we have the right logic, we can move our script to an _ingest pipeline_ -- let's do that next!

[.text-4xl]
[.text-white]
== Ingest Pipelines with Painless
image::green-background.png[background, size=cover]

[.text-3xl]
== Ingest Pipelines
image::white-background.png[background, size=cover]

* An _ingest pipeline_ transforms a document just before it is indexed

* Pipelines thus provide an ELT solution internal to the cluster

* Pipelines are execute by _ingest nodes_ in an Elasticsearch cluster

** So, in order to use a pipeline, you must be at least on ingest node in your cluster

* Pipelines can intercept a document during a create or update operation

** That is, a pipeline can be used on `_reindex`, `_update_by_query`, `_bulk`,  and document creation

** An index can also specify, in its settings, a default pipeline which will intercept every document is written to it

[.text-3xl]
== Ingest Pipelines (continued)
image::white-background.png[background, size=cover]

* Pipelines execute as an sequence of processors, each passing the document from one to the next

** There are many out-of-the-box processors such as `grok`, `set`, `enrich`, and others

** In this course, we are interested in writing our own custom `script` processors

* Pipelines provide an ideal location for fixing data defects, adding new fields, running expensive computations, etc.

* The Painless *Ingest Processor* context will provide a script access to the input document’s fields through the `ctx` local variable

[.text-3xl]
== A Better Solution using an Ingest Pipeline
image::white-background.png[background, size=cover]

* Let’s go ahead and use a pipeline to solve the trip duration problem

* The new `find_trip_duration` pipeline will

** Add (and populate) a `trip_duration` field to a document

** Convert the arrival and departure dates to ISO 8601 format — which will be parsed properly by ES on indexing

* We will also replace the dynamically-generated mapping for the `trips` index with an explicit mapping

** We will define the exact types we want for the fields in the index

** We will also set the pipeline to be the default pipeline for the index

[.text-2xl]
== The `find_trip_duration` Pipeline
image::white-background.png[background, size=cover]

[.text-left]
* Using our reusable functions as building blocks, developing the pipeline is straight-forward

```
include::../code/070_trip_duration_pipeline.painless[]
```

[.text-left]
** Note the use of the `ctx` context variable to access document fields

[.text-2xl]
== Simulating the Pipeline
image::white-background.png[background, size=cover]

[.text-left]
* We can use the _simulate endpoint to test the pipeline

```
include::../code/072_trip_duration_pipeline_simulation.painless[]
```

[.text-left]
* After going through the pipeline, documents now have the desired `trip_duration` field

```
include::../code/074_trip_duration_pipeline_results.painless[]
```

[.text-2xl]
== The `trips` Index Definition
image::white-background.png[background, size=cover]

[.text-left]
* We now define the types of each of the fields in the index, plus we can specify our new pipeline as the default

```
include::../code/076_trip_duration_pipeline_index_definition.painless[]
```

[.text-3xl]
== Analyzing the Ingest Pipeline Solution
image::white-background.png[background, size=cover]

[.text-left]
* We now have a very good solution!

** The script that calculates trip duration and converts custom dates to ISO 8601 format is run only once per document on indexing (or reindexing)

** We solved the problem by breaking it down into subproblems and now have two new functions that can be used to solve other problems

** We followed an iterative approach where we developed an initial solution, analyzed it, and improved it

[.text-4xl]
[.text-white]
== Summary: Problem Solving with Painless
image::green-background.png[background, size=cover]

[.text-3xl]
== Summary
image::white-background.png[background, size=cover]

* We used our new Painless scripting skills to solve a complete problem

* We used an iterative approach to problem solving that involved

** Breaking down the problem and solving the sub-problems

** Developing a quick prototype to validate the logic

** Analyzing the initial solution and developing an improved solution

* We developed and tested the building blocks separately

* We were able to improve the quality of the index definition as part of the solution

[.text-3xl]
== Quiz
image::white-background.png[background, size=cover]

. *True or False*: As long as a script is correct, it is OK to run it at query time

. How can Painless help Elasticsearch work with custom date formats?

. *True or False*: A pipeline can create new fields or change their values in the document source

. What is a great location for a pipeline that guarantees it will process every document at indexing time?

. *True or False*: We had to change our logic when moving our script from query to ingest time

[.text-3xl]
=== Quiz Answers
image::white-background.png[background, size=cover]

. *False*. If possible, a script should be run as few times as possible, e.g., ingest time vs. query time

. Painless can use Java API’s to parse custom formats and convert them to a `ZonedDatetime`

. *True*

. The settings of an index can be used to define a default pipeline

. *False*. The logic of the solution was encapsulated in functions which were independent of the Painless context in use during execution


[.text-4xl]
[.text-white]
== Lab 4: Problem Solving with Painless
image::green-background.png[background, size=cover]